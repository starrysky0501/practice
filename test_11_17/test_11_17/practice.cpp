//另类加法
//class UnusualAdd {
//public:
//	int addAB(int A, int B) {
//		int  carrybit = 0;     
//		int sumbit = 0;        
//		while (B != 0)
//		{
//			sumbit = A^B;             //异或运算结果与两数加的结果相同，不包含进位
//			carrybit = (A & B) << 1;  //产生进位的位
//			A = sumbit;
//			B = carrybit;
//		}
//		return A;
//	}
//};
//请编写一个函数，将两个数字相加。不得使用+或其他算数运算符。
//举个栗子：
//A：1010	B：1101
//首先，我们先将A和B进行异或：
//	   A^B=1010^1101=0111，我们可以观察到，实现了两数的和，但没将进位的数字计算到数字中
//接着，我们采用按位或的方式求进位的位，
//	   (A & B)<<1=(1010 & 1101)<<1=10000 ,当两个数的同一位都为1的时候，才会产生进位，进
//     位是加到当前位的下一位，所以我们采用左移的方式，得到进位的位。
//最后，我们将异或和按位或的结果再求一次异或，直到B为0，这表明，进位的值已经处理完。  
//最后说明：为什么要采用循环？
//因为，当进位的位与异或的值异或后，有可能也会产生进位的值，所以我们应循环处理，直到表示进位的值B为0.



//请编写一个函数（允许增加子函数），计算n x m的棋盘格子（n为横向的格子数，m为竖向的格子数）沿着各自边缘线
//从左上角走到右下角,总共有多少种走法，要求不能走回头路，即：只能往右和往下走，不能往左和往上走。
//#include<iostream>
//using namespace std;
//int chessboard(int m, int n)
//{
//	if (m == 0 || n == 0)
//	{
//		return 1;
//	}
//	return chessboard(m - 1, n) + chessboard(m, n - 1);
//}
//int main()
//{
//	int m, n;
//	while (cin >> m >> n)
//	{
//		int total = chessboard(m, n);
//		cout << total << endl;
//	}
//	return 0;
//}
//思路：采用递归的方式，(m,n)的棋盘只能向右向下走，它是由(m-1,n)+(m,n-1)种方法组成。