//牛客：马戏团(动态规划)

//题目描述
//搜狐员工小王最近利用假期在外地旅游，在某个小镇碰到一个马戏团表演，精彩的表演结束后发现团长正和大伙在帐篷前激烈讨
//论，小王打听了下了解到， 马戏团正打算出一个新节目“最高罗汉塔”，即马戏团员叠罗汉表演。考虑到安全因素，要求叠罗汉
//过程中，站在某个人肩上的人应该既比自己矮又比自己瘦，或相等。 团长想要本次节目中的罗汉塔叠的最高，由于人数众多，正
//在头疼如何安排人员的问题。小王觉得这个问题很简单，于是统计了参与最高罗汉塔表演的所有团员的身高体重，并且很快找到叠
//最高罗汉塔的人员序列。 现在你手上也拿到了这样一份身高体重表，请找出可以叠出的最高罗汉塔的高度，这份表中马戏团员依
//次编号为1到N。
//输入描述 :
//首先一个正整数N，表示人员个数。
//之后N行，每行三个数，分别对应马戏团员编号，体重和身高。
//输出描述 :
//正整数m，表示罗汉塔的高度。

#include<iostream>
#include<algorithm>
#include<vector>
using namespace std;
struct player
{
	int w;
	int h;
};

bool cmp_w(player p1, player p2)
{
	if (p1.w != p2.w)
	{
		return p1.w<p2.w;
	}
	else
	{
		return p1.h>p2.h;
	}
}
int main()
{
	int n;
	while (cin >> n)
	{
		vector<player> p(n);
		int w, h, index;
		for (int i = 0; i<n; ++i)
		{
			cin >> index >> w >> h;
			p[i].w = w;
			p[i].h = h;
		}
		sort(p.begin(), p.end(), cmp_w);
		vector<int> dp(n, 1);
		int max_p = 1;
		for (int i = 0; i<n; ++i)
		{
			for (int j = 0; j < i; ++j)
			{
				if (p[j].h <= p[i].h)
				{
					dp[i] = max(dp[i], dp[j] + 1);
				}
			}
			max_p = max(max_p, dp[i]);
		}
		cout << max_p << endl;
	}
	return 0;
}

//该题思路：
//对体重进行升序排列，当体重相同时，按身高的降序排列(对于相同的体重来说),之后对身高进行最长上升子序列排序，采用动态
//规划的思想。
//通过阅读该题在牛客下面的评论发现：
//1.当身高和体重相同时可以叠罗汉
//2.当身高且体重都不同时则可以叠罗汉
//3.当身高相同，体重轻的玩家可以在体重重的玩家的上方
//4.注：当体重相同时，则身高低的玩家不可以在身高高的玩家的上方
//所以：对体重进行升序排列，当体重相等时，则身高高的在身高低的前面(破坏按照身高的最长升序子序列),
//因为当体重相同，则身高低的在前面，会导致按照身高求最长子序列时，不满足第四点。

//知识点补充：
//sort函数的用法
//形式：sort(first_pointer, first_pointer + n, cmp)
//参数解释： 第一个参数是数组的首地址，一般写上数组名就可以，因为数组名是一个指针常量。第二个参数相对较好理解，
//即首地址加上数组的长度n（代表尾地址的下一地址）。最后一个参数是比较函数的名称（自定义函数cmp），这个比较函数
//可以不写，即第三个参数可以缺省，这样sort会默认按数组升序排序。
//简单例子：对数组A的0~n - 1元素进行升序排序，只要写sort(A, A + n)即可；对于向量V也一样，sort(v.begin(), v.end())
//sort的实现原理：
//实现原理：sort并不是简单的快速排序，它对普通的快速排序进行了优化，此外，它还结合了插入排序和推排序。系统会根据
//你的数据形式和数据量自动选择合适的排序方法，这并不是说它每次排序只选择一种方法，它是在一次完整排序中不同的情况
//选用不同方法，比如给一个数据量较大的数组排序，开始采用快速排序，分段递归，分段之后每一段的数据量达到一个较小值
//后它就不继续往下递归，而是选择插入排序，如果递归的太深，他会选择推排序。
//大佬对于sort用法总结的链接：https://www.cnblogs.com/jcyz/p/8793005.html
