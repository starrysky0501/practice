//牛客：年会抽奖

//今年公司年会的奖品特别给力，但获奖的规矩却很奇葩：
//1. 首先，所有人员都将一张写有自己名字的字条放入抽奖箱中；
//2. 待所有字条加入完毕，每人从箱中取一个字条；
//3. 如果抽到的字条上写的就是自己的名字，那么“恭喜你，中奖了！”
//现在告诉你参加晚会的人数，请你计算有多少概率会出现无人获奖？
//输入描述 :
//输入包含多组数据，每组数据包含一个正整数n（2≤n≤20）。
//输出描述 :
//对应每一组数据，以“xx.xx%”的格式输出发生无人获奖的概率。

//#include<iostream>
//using namespace std;
//int main()
//{
//	long long num[21] = { 0, 0, 1 }; //n个人都拿错的情况总数
//	long long sum[21] = { 1, 1, 2 }; //排列组合所有出现的可能情况
//	for (int i = 3; i<21; ++i)
//	{
//		num[i] = (i - 1)*(num[i - 1] + num[i - 2]);
//		sum[i] = i*sum[i - 1];
//	}
//	int n;
//	while (cin >> n)
//	{
//		printf("%4.2f%%\n", 100.0*num[n] / sum[n]);
//	}
//	return 0;
//}

//解题思路：
//无人获奖：所有人都拿到了别人的名字，没有拿到自己的名字
//全部都不获奖的概率：n个人都拿错的情况总数/n个人拿出的所有排列情况数(不放回实验:n的阶乘)
//拿错的情况总数：错排算法
//当n个编号元素放在n个编号位置，各不对应的方法数用D(n)表示
//1.把第n个编号元素放在一个位置，例如用字母表示为k位置，则k有n-1中情况
//2.则接着有两种情况：
//  (1).第k个元素放在第n个位置：则第k个元素和第n个元素互相交换了位置，则剩下n-2个元素，则有D(n-2)种方法
//  (2).第k个元素不在第n个位置，则应对应n-1个元素放在不同的位置，则有D(n-1)种方法
//3.综上所得递推公式：D(n)=(n-1)* [ D(n-1)+D(n-2) ]
//4.已知条件：D(1)=0,D(2)=1
//-----------------------------------------
//举例：5个正整数的错排：
//当n=1，由于只有1个数，不可能有错排，所以a1=0;
//当n=2，两个数的错排是唯一的，所以a2=1;
//当n=3,三个数1，2，3的错排有：2,3,1 / 3,1,2  所以a3=2;
//当n=4，错排有：2,1,4,3(1，2交换) / 2,3,4,1 / 2,4,1,3
//				 3,4,1,2(1，3交换) / 3,1,4,2 / 3,4,2,1
//				 4,3,2,1(1，4交换) / 4,1,2,3 / 4,3,1,2    所以a4=9
//当n=5,你就会发现递推公式啦!!!