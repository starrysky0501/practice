//题目描述
//在十进制表示中，任意一个正整数都可以用字符’0’ - ‘9’表示出来。但是当’0’ - ‘9’这些字符每种字符的数量有限时，可能有些正整数就无法表示出来了。比如你有两个‘1’，一个‘2’，那么你能表示出11，12，121等等，但是无法表示出10，122，200等数。
//现在你手上拥有一些字符，它们都是’0’ - ‘9’的字符。你可以选出其中一些字符然后将它们组合成一个数字，那么你所无法组成的最小的正整数是多少？
//输入描述 :
//第一行包含一个由字符’0’ - ‘9’组成的字符串，表示你可以使用的字符。
//1 ≤字符串长度≤ 1000
//输出描述 :
//输出你所无法组成的最小正整数
//
////#include<iostream>
////#include<algorithm>
////using namespace std;
////int num[10] = { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 };
////int a[10] = { 1 };//出现的次数，‘0’的次数初值赋为1,其余为0
////bool cmp(int x, int y)//设置比较函数，将10个字符按出现次数从少到多排列
////{
////	return a[x]<a[y];
////}
////int main()
////{
////	string str;
////	cin >> str;
////	for (auto c : str)
////	{
////		a[c - 48]++;//记录字符出现次数
////	}
////	stable_sort(num, num + 10, cmp);//次数相同时，值小的排在前面
////	num[0] == 0 ? cout << 1 : cout << num[0];
////	for (int i = 0; i<a[num[0]]; cout << num[0], i++);
////}
