//牛客：发邮件

//题目描述：
//NowCoder每天要给很多人发邮件。有一天他发现发错了邮件，把发给A的邮件发给了B，把发给B的邮件发给了A。于是他就思考，要给n个人发
//邮件，在每个人仅收到1封邮件的情况下，有多少种情况是所有人都收到了错误的邮件？即没有人收到属于自己的邮件。
//输入描述 :
//输入包含多组数据，每组数据包含一个正整数n（2≤n≤20）。
//输出描述 :
//对应每一组数据，输出一个正整数，表示无人收到自己邮件的种数。

#include<iostream>
using namespace std;
int main()
{
	long long arr[21] = { 0, 0, 1 };
	int n;
	while (cin >> n)
	{
		for (int i = 3; i<21; ++i)
		{
			arr[i] = (i - 1)*(arr[i - 1] + arr[i - 2]);    //排列组合中的错排思想
		}
		cout << arr[n] << endl;
	}
	return 0;
}

//和“年会抽奖”的思想一摸一样，只是输出的方式不同

//拿错的情况总数：错排算法
//当n个编号元素放在n个编号位置，各不对应的方法数用D(n)表示
//1.把第n个编号元素放在一个位置，例如用字母表示为k位置，则k有n-1中情况
//2.则接着有两种情况：
//  (1).第k个元素放在第n个位置：则第k个元素和第n个元素互相交换了位置，则剩下n-2个元素，则有D(n-2)种方法
//  (2).第k个元素不在第n个位置，则应对应n-1个元素放在不同的位置，则有D(n-1)种方法
//3.综上所得递推公式：D(n)=(n-1)* [ D(n-1)+D(n-2) ]
//4.已知条件：D(1)=0,D(2)=1